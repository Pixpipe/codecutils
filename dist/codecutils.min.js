// Build date: 2017-0815T14:03:25

/*
* Author    Jonathan Lurie - http://me.jonahanlurie.fr
* License   MIT
* Link      https://github.com/jonathanlurie/pixbincodec
* Lab       MCIN - http://mcin.ca/ - Montreal Neurological Institute
*/
(function(f,e){"object"===typeof exports&&"undefined"!==typeof module?e(exports):"function"===typeof define&&define.amd?define(["exports"],e):e(f.codecutils=f.codecutils||{})})(this,function(f){var e=function(){};e.isPlatformLittleEndian=function(){var a=new Uint32Array([305419896]);return 18!=(new Uint8Array(a.buffer,a.byteOffset,a.byteLength))[0]};e.arrayBufferToString16=function(a){return String.fromCharCode.apply(null,new Uint16Array(a))};e.string16ToArrayBuffer=function(a){for(var c=new ArrayBuffer(2*
a.length),b=new Uint16Array(c),d=0;d<a.length;d++)b[d]=a.charCodeAt(d);return c};e.arrayBufferToString8=function(a){return String.fromCharCode.apply(null,new Uint8Array(a))};e.string8ToArrayBuffer=function(a){for(var c=new ArrayBuffer(a.length),b=new Uint8Array(c),d=0;d<a.length;d++)b[d]=a.charCodeAt(d);return c};e.setString8InBuffer=function(a,c,b){b=void 0===b?0:b;if(0>b)console.warn("The byte offset cannot be negative.");else if(c&&c instanceof ArrayBuffer)if(a.length+b>c.byteLength)console.warn("The string is too long to be writen in this buffer.");
else{c=new Uint8Array(c);for(var d=0;d<a.length;d++)c[d+b]=a.charCodeAt(d)}else console.warn("The buffer must be a valid ArrayBuffer.")};e.getString8FromBuffer=function(a,c,b){b=void 0===b?0:b;return 0>b?(console.warn("The byte offset cannot be negative."),null):a&&a instanceof ArrayBuffer?c+b>a.byteLength?(console.warn("The string is too long to be writen in this buffer."),null):String.fromCharCode.apply(null,new Uint8Array(a,b,c)):(console.warn("The buffer must be a valid ArrayBuffer."),null)};
e.objectToArrayBuffer=function(a){var c=null;try{var b=JSON.stringify(a),c=e.string16ToArrayBuffer(b)}catch(d){console.warn(d)}return c};e.ArrayBufferToObject=function(a){var c=null;try{var b=e.arrayBufferToString16(a),c=JSON.parse(b)}catch(d){console.warn(d)}return c};e.isTypedArray=function(a){return a instanceof Int8Array||a instanceof Uint8Array||a instanceof Uint8ClampedArray||a instanceof Int16Array||a instanceof Uint16Array||a instanceof Int32Array||a instanceof Uint32Array||a instanceof Float32Array||
a instanceof Float64Array};e.mergeBuffers=function(a){for(var c=0,b=0;b<a.length;b++)c+=a[b].byteLength;for(var c=new Uint8Array(c),d=0,b=0;b<a.length;b++)c.set(new Uint8Array(a[b]),d),d+=a[b].byteLength;return c.buffer};e.getGlobalObject=function(){var a=null;try{a=window}catch(c){try{a=GLOBAL}catch(b){return console.warn("You are not in a Javascript environment?? Weird."),null}}return a};e.extractTypedArray=function(a,c,b,d){if(!a)return console.warn("Input Buffer is null."),null;if(!(a instanceof
ArrayBuffer))return console.warn("Buffer must be of type ArrayBuffer"),null;if(0>=d)return console.warn("The number of elements to fetch must be greater than 0"),null;if(0>c)return console.warn("The byte offset must be possitive or 0"),null;if(c>=a.byteLength)return console.warn("The offset cannot be larger than the size of the buffer."),null;if(b instanceof Function&&!("BYTES_PER_ELEMENT"in b))return console.warn("ArrayType must be a typed array constructor function."),null;if(b.BYTES_PER_ELEMENT*
d+c>a.byteLength)console.warn("The requested number of elements is too large for this buffer");else return a=a.slice(c,c+d*b.BYTES_PER_ELEMENT),new b(a)};f.CodecUtils=e;Object.defineProperty(f,"__esModule",{value:!0})});
